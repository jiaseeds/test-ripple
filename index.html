<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Premium Ripple Landing</title>
  <style>
    :root {
      --content-max-width: 1100px;
    }
    html, body {
      height: 100%;
      margin: 0;
      background: #0b0d10;
      overflow: hidden; /* keep it immersive */
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    /* WebGL canvas covers the screen */
    #gl {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
    }

    /* Overlay content (logo + slogan) */
    .overlay {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none; /* clicks pass through */
      padding: clamp(16px, 3vmin, 40px);
    }
    .hero {
      max-width: var(--content-max-width);
      width: min(92vw, var(--content-max-width));
      display: grid;
      gap: clamp(12px, 1.8vmin, 24px);
      justify-items: center;
      text-align: center;
      pointer-events: none;
      color: #ffffff;
      text-shadow: 0 2px 12px rgba(0,0,0,.45);
      backdrop-filter: none;
    }
    .logo {
      width: clamp(120px, 22vmin, 220px);
      height: auto;
      filter: drop-shadow(0 8px 20px rgba(0,0,0,.35));
      pointer-events: auto; /* allow hover on logo */
    }
    h1 {
      margin: 0;
      font-weight: 700;
      letter-spacing: .02em;
      line-height: 1.1;
      font-size: clamp(22px, 3.8vmin, 44px);
    }
    p.tagline {
      margin: 0;
      opacity: .9;
      font-weight: 400;
      letter-spacing: .02em;
      line-height: 1.35;
      font-size: clamp(14px, 2.1vmin, 20px);
      max-width: 60ch;
    }

    /* Subtle “enter” fade */
    .overlay, #gl { animation: fadeIn .75s ease-out both; }
    @keyframes fadeIn { from { opacity: 0 } to { opacity: 1 } }

    /* Optional: small “scroll to explore” indicator on desktop */
    .hint {
      position: fixed;
      left: 50%;
      bottom: clamp(12px, 2.5vmin, 28px);
      transform: translateX(-50%);
      color: rgba(255,255,255,.75);
      font-size: 12px;
      letter-spacing: .12em;
      text-transform: uppercase;
      pointer-events: none;
      user-select: none;
    }

    /* Mobile safe area */
    @supports (padding: max(0px)) {
      .overlay { padding: max(16px, env(safe-area-inset-top)) max(16px, env(safe-area-inset-right)) max(16px, env(safe-area-inset-bottom)) max(16px, env(safe-area-inset-left)); }
    }
  </style>
</head>
<body>

<canvas id="gl"></canvas>

<div class="overlay">
  <div class="hero">
    <img class="logo" id="logo" alt="Brand logo" src="https://assets.githubusercontent.com/images/modules/logos_page/GitHub-Mark.png" />
    <h1 id="headline">Where ideas meet the waterline</h1>
    <p class="tagline" id="tagline">Crafted experiences with depth, clarity, and a gentle ripple of wonder.</p>
  </div>
</div>

<div class="hint">Move your mouse / tap to ripple</div>

<script>
/* ===========================
   TUNABLES — tweak as needed
   =========================== */
const BACKGROUND_URL = "https://images.unsplash.com/photo-1469474968028-56623f02e42e?q=80&w=1920&auto=format&fit=crop"; // your background
// Optional: replace logo & text at runtime (or edit HTML above)
document.getElementById('logo').src = "https://upload.wikimedia.org/wikipedia/commons/a/a7/React-icon.svg";
document.getElementById('headline').textContent = "Make waves with your brand";
document.getElementById('tagline').textContent = "A premium landing with WebGL water ripples.";

const MAX_DROPS = 10;       // how many simultaneous ripples to keep
const RIPPLE_AMPLITUDE = 0.012; // displacement strength (0.006–0.02 is subtle)
const RIPPLE_FREQUENCY = 24.0;  // wave frequency (higher = tighter ripples)
const RIPPLE_SPEED = 0.55;      // outward speed (0.4–0.8 works well)
const DISTANCE_DECAY = 3.5;     // how quickly ripples fade over distance
const TIME_DECAY = 0.9;         // how quickly each ripple fades over time
const CHROMA = 0.0017;          // tiny chromatic aberration for wet look (0 to disable)
const MOUSE_THROTTLE_MS = 30;   // limit how often we add drops on mousemove
/* =========================== */

const dpr = Math.min(window.devicePixelRatio || 1, 2);
const canvas = document.getElementById('gl');
const gl = canvas.getContext('webgl', { antialias: true, alpha: true, powerPreference: "high-performance" });

if (!gl) {
  document.body.innerHTML = "<div style='display:grid;place-items:center;height:100vh;color:#fff;text-align:center;padding:24px'>Your browser doesn't support WebGL. Please try a modern browser.</div>";
  throw new Error("WebGL not supported");
}

function resize() {
  const w = Math.floor(window.innerWidth * dpr);
  const h = Math.floor(window.innerHeight * dpr);
  if (canvas.width !== w || canvas.height !== h) {
    canvas.width = w; canvas.height = h;
    canvas.style.width = window.innerWidth + "px";
    canvas.style.height = window.innerHeight + "px";
    gl.viewport(0, 0, w, h);
  }
}
window.addEventListener('resize', resize, { passive: true });
resize();

/* ---------- Shader sources ---------- */
// Fullscreen triangle vertex shader
const vs = `
attribute vec2 a_position;
varying vec2 v_uv;
void main() {
  // Map clip-space triangle to uv
  v_uv = (a_position + 1.0) * 0.5;
  gl_Position = vec4(a_position, 0.0, 1.0);
}`;

// Fragment shader: refractive ripples
const fs = `
precision highp float;

uniform sampler2D u_tex;
uniform vec2 u_resolution;
uniform float u_time;

// Ripple params
const int MAX_DROPS = ${MAX_DROPS};
uniform vec2  u_centers[MAX_DROPS];
uniform float u_startT[MAX_DROPS];
uniform float u_active[MAX_DROPS]; // 1.0 if alive else 0.0

uniform float u_amp;
uniform float u_freq;
uniform float u_speed;
uniform float u_distDecay;
uniform float u_timeDecay;
uniform float u_chroma;

varying vec2 v_uv;

vec2 aspectCorrect(vec2 uv) {
  // Keep image cover/centered with similar behavior to CSS background-size: cover
  float canvasRatio = u_resolution.x / u_resolution.y;
  float imageRatio = 16.0/9.0; // will be updated dynamically via uniform override if needed
  // (We’ll compute true ratio in JS and pass via uniform over u_coverScale and u_coverOffset)
  return uv;
}

void main() {
  vec2 uv = v_uv;

  // Accumulate displacement from each active ripple
  vec2 totalOffset = vec2(0.0);
  float t = u_time;

  for (int i = 0; i < MAX_DROPS; i++) {
    if (u_active[i] < 0.5) continue;

    vec2 c = u_centers[i];
    float start = u_startT[i];
    float age = max(t - start, 0.0);

    // outward-moving wavefront
    float dist = distance(uv, c) + 1e-6;
    float phase = (dist - age * u_speed) * u_freq;

    // attenuate by distance and time (soft cutoff outside the moving ring)
    float envelope = exp(-u_distDecay * dist) * exp(-u_timeDecay * age);

    // ripple displacement along radial direction
    float disp = sin(phase) * envelope * u_amp;

    totalOffset += normalize(uv - c) * disp;
  }

  // tiny chromatic aberration adds "wet" realism (optional)
  vec4 base;
  if (u_chroma > 0.0) {
    float s = u_chroma;
    float r = texture2D(u_tex, uv + totalOffset * (1.0 + s)).r;
    float g = texture2D(u_tex, uv + totalOffset).g;
    float b = texture2D(u_tex, uv + totalOffset * (1.0 - s)).b;
    base = vec4(r, g, b, 1.0);
  } else {
    base = texture2D(u_tex, uv + totalOffset);
  }

  gl_FragColor = base;
}`;

/* ---------- Build program ---------- */
function createShader(type, source) {
  const s = gl.createShader(type);
  gl.shaderSource(s, source);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(s));
    throw new Error("Shader compile failed");
  }
  return s;
}
function createProgram(vsSource, fsSource) {
  const program = gl.createProgram();
  const v = createShader(gl.VERTEX_SHADER, vsSource);
  const f = createShader(gl.FRAGMENT_SHADER, fsSource);
  gl.attachShader(program, v);
  gl.attachShader(program, f);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(program));
    throw new Error("Program link failed");
  }
  return program;
}
const program = createProgram(vs, fs);
gl.useProgram(program);

/* ---------- Fullscreen triangle ---------- */
const quad = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quad);
// Big triangle covering the screen
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -1, -1,
   3, -1,
  -1,  3,
]), gl.STATIC_DRAW);
const a_position = gl.getAttribLocation(program, "a_position");
gl.enableVertexAttribArray(a_position);
gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);

/* ---------- Load background texture ---------- */
function createTexture(img) {
  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
  return tex;
}

const image = new Image();
image.crossOrigin = "anonymous";
image.src = BACKGROUND_URL;
let texture = null;
let imageAspect = 16/9;
image.onload = () => {
  imageAspect = image.width / image.height;
  texture = createTexture(image);
};

/* ---------- Uniforms ---------- */
const uni = (name) => gl.getUniformLocation(program, name);
const u_tex = uni("u_tex");
const u_resolution = uni("u_resolution");
const u_time = uni("u_time");
const u_centers = [...Array(MAX_DROPS)].map((_, i) => uni(`u_centers[${i}]`));
const u_startT = [...Array(MAX_DROPS)].map((_, i) => uni(`u_startT[${i}]`));
const u_active = [...Array(MAX_DROPS)].map((_, i) => uni(`u_active[${i}]`));

gl.uniform1f(uni("u_amp"), RIPPLE_AMPLITUDE);
gl.uniform1f(uni("u_freq"), RIPPLE_FREQUENCY);
gl.uniform1f(uni("u_speed"), RIPPLE_SPEED);
gl.uniform1f(uni("u_distDecay"), DISTANCE_DECAY);
gl.uniform1f(uni("u_timeDecay"), TIME_DECAY);
gl.uniform1f(uni("u_chroma"), CHROMA);

/* ---------- Ripple state ---------- */
const drops = Array.from({ length: MAX_DROPS }, () => ({
  active: 0,
  x: 0.5,
  y: 0.5,
  t: 0
}));
let dropCursor = 0;

function addDrop(nx, ny, time) {
  const d = drops[dropCursor];
  d.active = 1;
  d.x = nx;
  d.y = ny;
  d.t = time;
  dropCursor = (dropCursor + 1) % MAX_DROPS;
}

/* ---------- Interaction ---------- */
let lastEmit = 0;
function emitFromEvent(e, multi = 1) {
  const rect = canvas.getBoundingClientRect();
  let x, y;
  if (e.touches && e.touches.length) {
    const t = e.touches[0];
    x = (t.clientX - rect.left) / rect.width;
    y = (t.clientY - rect.top) / rect.height;
  } else {
    x = (e.clientX - rect.left) / rect.width;
    y = (e.clientY - rect.top) / rect.height;
  }
  const now = performance.now();
  if (now - lastEmit > MOUSE_THROTTLE_MS) {
    for (let i = 0; i < multi; i++) {
      // small scatter for richer look
      const jx = (Math.random() - 0.5) * 0.004;
      const jy = (Math.random() - 0.5) * 0.004;
      addDrop(x + jx, y + jy, now * 0.001);
    }
    lastEmit = now;
  }
}

window.addEventListener('mousemove', (e) => emitFromEvent(e, 1), { passive: true });
window.addEventListener('touchstart', (e) => emitFromEvent(e, 3), { passive: true });
window.addEventListener('touchmove', (e) => emitFromEvent(e, 1), { passive: true });

/* ---------- Render loop ---------- */
function render(timeMs) {
  resize();
  const t = timeMs * 0.001;

  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.uniform1i(u_tex, 0);

  gl.uniform2f(u_resolution, canvas.width, canvas.height);
  gl.uniform1f(u_time, t);

  // Upload ripple uniforms
  for (let i = 0; i < MAX_DROPS; i++) {
    const d = drops[i];
    // Auto-deactivate very old ripples
    if (d.active && (t - d.t) > 6.0) d.active = 0;
    gl.uniform2f(u_centers[i], d.x, 1.0 - d.y); // flip Y so it matches DOM coords
    gl.uniform1f(u_startT[i], d.t);
    gl.uniform1f(u_active[i], d.active ? 1.0 : 0.0);
  }

  gl.drawArrays(gl.TRIANGLES, 0, 3);
  requestAnimationFrame(render);
}
requestAnimationFrame(render);

// First gentle ripple so page feels alive
setTimeout(() => addDrop(0.5, 0.55, performance.now() * 0.001), 350);
</script>

</body>
</html>
