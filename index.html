<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>The Wave Towers</title>

  <style>
    /* ===========================
       1. CUSTOM FONT INTEGRATION
       =========================== */
    @font-face {
      font-family: 'ParkLaneLight';
      src: url('./fonts/PARK LANE W00 LIGHT.TTF') format('truetype'); /* fallback */
    
    }

    /* ===========================
       2. GLOBAL VARIABLES
       =========================== */
    :root {
      --accent-color: #00c6ff; /* Button accent color */
      --hero-spacing-right: clamp(140px, 18vw, 260px); /* distance from right edge */
    }

    /* ===========================
       3. GLOBAL RESET
       =========================== */
    html, body {
      height: 100%;
      margin: 0;
      background: #0b0d10;
      overflow: hidden;
      font-family: 'ParkLaneLight', Arial, sans-serif;
    }

    /* ===========================
       4. WEBGL BACKGROUND
       =========================== */
    #gl {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
      z-index: 0;
      opacity: 0;
      transition: opacity 1s ease-out; /* Smooth fade-in */
    }
    #gl.loaded {
      opacity: 1;
    }

    /* ===========================
       5. SUBTLE FADE GRADIENT
       =========================== */
    .fade-overlay {
      position: fixed;
      inset: 0;
      background: linear-gradient(to left, rgba(11,13,16,0.35), rgba(11,13,16,0));
      pointer-events: none;
      z-index: 1;
    }

    /* ===========================
       6. HERO OVERLAY CONTAINER
       =========================== */
    .overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      pointer-events: none;
      z-index: 2;
    }

    .hero-wrapper {
      margin-right: var(--hero-spacing-right);
      pointer-events: auto;
    }

    /* ===========================
       7. HERO CONTENT
       =========================== */
    .hero {
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      max-width: 460px;
      gap: clamp(14px, 2vmin, 22px);
      color: #ffffff;
      text-shadow: 0 2px 12px rgba(0,0,0,.45);
    }

    .logo {
      width: clamp(90px, 18vmin, 160px);
      height: auto;
      filter: drop-shadow(0 8px 20px rgba(0,0,0,.35));
      margin-bottom: 10px;
    }

    h1 {
      margin: 0;
      font-weight: 300; /* matches light weight */
      line-height: 1.1;
      letter-spacing: 0.03em;
      font-size: clamp(22px, 3.8vmin, 48px);
    }

    p.tagline {
      margin: 0;
      opacity: 0.9;
      font-weight: 300;
      line-height: 1.35;
      font-size: clamp(14px, 2vmin, 20px);
      max-width: 40ch;
    }

    /* ===========================
       8. EXPLORE BUTTON
       =========================== */
    .btn-explore {
      display: inline-block;
      padding: 12px 28px;
      background: #2A3867; /* Updated to your new color */
      color: white;
      font-size: 16px;
      font-weight: 600;
      text-decoration: none;
      border-radius: 50px;
      transition: background 0.3s ease, transform 0.25s ease, box-shadow 0.3s ease;
      /* Subtle glow that blends with the dark background */
      box-shadow: 0 4px 14px rgba(255, 255, 255, 0.08);
      margin-top: 10px;
      font-family: 'ParkLaneLight', Arial, sans-serif;
    }
    .btn-explore:hover {
      background: #081F2C;
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(255, 255, 255, 0.08);
    }

    /* ===========================
       9. SCROLL HINT TEXT
       =========================== */
    .hint {
      position: fixed;
      left: 50%;
      bottom: clamp(12px, 2.5vmin, 28px);
      transform: translateX(-50%);
      color: rgba(255,255,255,.75);
      font-size: 12px;
      letter-spacing: .12em;
      text-transform: uppercase;
      pointer-events: none;
      user-select: none;
      z-index: 3;
    }

    /* ===========================
       10. FADE-IN ANIMATION
       =========================== */
    .overlay, #gl { animation: fadeIn .75s ease-out both; }
    @keyframes fadeIn { from { opacity: 0 } to { opacity: 1 } }

    /* Mobile safe area */
    @supports (padding: max(0px)) {
      .overlay {
        padding: max(16px, env(safe-area-inset-top))
                 max(16px, env(safe-area-inset-right))
                 max(16px, env(safe-area-inset-bottom))
                 max(16px, env(safe-area-inset-left));
      }
    }
  </style>
</head>
<body>

<!-- WebGL Canvas for Ripple Effect -->
<canvas id="gl"></canvas>

<!-- Optional Gradient Overlay -->
<div class="fade-overlay"></div>

<!-- Overlay with Hero Content -->
<div class="overlay">
  <div class="hero-wrapper">
    <div class="hero">
      <img class="logo" src="./images/the-wave-towers-stacked-cream.png" alt="Brand Logo">
      <h1>A New Wave of Living</h1>
      <a href="https://storage.net-fs.com/hosting/7319940/60/" class="btn-explore">Start Tour</a>
    </div>
  </div>
</div>

<!-- Hint -->
<!-- <div class="hint">Move your mouse / tap to ripple</div> -->

<script>
/* ===========================
   CONFIGURATION
   =========================== */
const BACKGROUND_URL = "./images/background-tower.jpg"; // <-- your local image

const MAX_DROPS = 10;
const RIPPLE_AMPLITUDE = 0.012;
const RIPPLE_FREQUENCY = 24.0;
const RIPPLE_SPEED = 0.55;
const DISTANCE_DECAY = 3.5;
const TIME_DECAY = 0.9;
const CHROMA = 0.0017;
const MOUSE_THROTTLE_MS = 30;

/* ===========================
   WEBGL SETUP
   =========================== */
const dpr = Math.min(window.devicePixelRatio || 1, 2);
const canvas = document.getElementById('gl');
const gl = canvas.getContext('webgl', { antialias: true, alpha: true, powerPreference: "high-performance" });

if (!gl) {
  document.body.innerHTML = "<div style='display:grid;place-items:center;height:100vh;color:#fff;text-align:center;padding:24px'>Your browser doesn't support WebGL.</div>";
  throw new Error("WebGL not supported");
}

function resize() {
  const w = Math.floor(window.innerWidth * dpr);
  const h = Math.floor(window.innerHeight * dpr);
  if (canvas.width !== w || canvas.height !== h) {
    canvas.width = w;
    canvas.height = h;
    canvas.style.width = window.innerWidth + "px";
    canvas.style.height = window.innerHeight + "px";
    gl.viewport(0, 0, w, h);
  }
}
window.addEventListener('resize', resize, { passive: true });
resize();

/* ===========================
   SHADERS
   =========================== */
const vs = `
attribute vec2 a_position;
varying vec2 v_uv;
void main() {
  v_uv = (a_position + 1.0) * 0.5;
  gl_Position = vec4(a_position, 0.0, 1.0);
}`;

const fs = `
precision highp float;

uniform sampler2D u_tex;
uniform vec2 u_resolution;
uniform float u_time;

const int MAX_DROPS = ${MAX_DROPS};
uniform vec2  u_centers[MAX_DROPS];
uniform float u_startT[MAX_DROPS];
uniform float u_active[MAX_DROPS];

uniform float u_amp;
uniform float u_freq;
uniform float u_speed;
uniform float u_distDecay;
uniform float u_timeDecay;
uniform float u_chroma;

varying vec2 v_uv;

void main() {
  vec2 uv = v_uv;
  vec2 totalOffset = vec2(0.0);
  float t = u_time;

  for (int i = 0; i < MAX_DROPS; i++) {
    if (u_active[i] < 0.5) continue;

    vec2 c = u_centers[i];
    float start = u_startT[i];
    float age = max(t - start, 0.0);

    float dist = distance(uv, c) + 1e-6;
    float phase = (dist - age * u_speed) * u_freq;

    float envelope = exp(-u_distDecay * dist) * exp(-u_timeDecay * age);

    float disp = sin(phase) * envelope * u_amp;
    totalOffset += normalize(uv - c) * disp;
  }

  vec4 base;
  if (u_chroma > 0.0) {
    float s = u_chroma;
    float r = texture2D(u_tex, uv + totalOffset * (1.0 + s)).r;
    float g = texture2D(u_tex, uv + totalOffset).g;
    float b = texture2D(u_tex, uv + totalOffset * (1.0 - s)).b;
    base = vec4(r, g, b, 1.0);
  } else {
    base = texture2D(u_tex, uv + totalOffset);
  }

  gl_FragColor = base;
}`;

/* ===========================
   PROGRAM CREATION
   =========================== */
function createShader(type, source) {
  const s = gl.createShader(type);
  gl.shaderSource(s, source);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(s));
    throw new Error("Shader compile failed");
  }
  return s;
}
function createProgram(vsSource, fsSource) {
  const program = gl.createProgram();
  gl.attachShader(program, createShader(gl.VERTEX_SHADER, vsSource));
  gl.attachShader(program, createShader(gl.FRAGMENT_SHADER, fsSource));
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(program));
    throw new Error("Program link failed");
  }
  return program;
}
const program = createProgram(vs, fs);
gl.useProgram(program);

/* ===========================
   FULLSCREEN TRIANGLE
   =========================== */
const quad = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quad);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -1, -1,
   3, -1,
  -1,  3,
]), gl.STATIC_DRAW);
const a_position = gl.getAttribLocation(program, "a_position");
gl.enableVertexAttribArray(a_position);
gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);

/* ===========================
   LOAD BACKGROUND IMAGE
   =========================== */
function createTexture(img) {
  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
  return tex;
}

const image = new Image();
image.crossOrigin = "anonymous";
image.src = BACKGROUND_URL;
let texture = null;
image.onload = () => {
  texture = createTexture(image);
  canvas.classList.add('loaded'); // smooth fade-in
};

/* ===========================
   UNIFORMS
   =========================== */
const uni = (name) => gl.getUniformLocation(program, name);
const u_tex = uni("u_tex");
const u_resolution = uni("u_resolution");
const u_time = uni("u_time");
const u_centers = [...Array(MAX_DROPS)].map((_, i) => uni(`u_centers[${i}]`));
const u_startT = [...Array(MAX_DROPS)].map((_, i) => uni(`u_startT[${i}]`));
const u_active = [...Array(MAX_DROPS)].map((_, i) => uni(`u_active[${i}]`));

gl.uniform1f(uni("u_amp"), RIPPLE_AMPLITUDE);
gl.uniform1f(uni("u_freq"), RIPPLE_FREQUENCY);
gl.uniform1f(uni("u_speed"), RIPPLE_SPEED);
gl.uniform1f(uni("u_distDecay"), DISTANCE_DECAY);
gl.uniform1f(uni("u_timeDecay"), TIME_DECAY);
gl.uniform1f(uni("u_chroma"), CHROMA);

/* ===========================
   RIPPLE STATE
   =========================== */
const drops = Array.from({ length: MAX_DROPS }, () => ({
  active: 0,
  x: 0.5,
  y: 0.5,
  t: 0
}));
let dropCursor = 0;

function addDrop(nx, ny, time) {
  const d = drops[dropCursor];
  d.active = 1;
  d.x = nx;
  d.y = ny;
  d.t = time;
  dropCursor = (dropCursor + 1) % MAX_DROPS;
}

/* ===========================
   INTERACTION
   =========================== */
let lastEmit = 0;
function emitFromEvent(e, multi = 1) {
  const rect = canvas.getBoundingClientRect();
  let x, y;
  if (e.touches && e.touches.length) {
    const t = e.touches[0];
    x = (t.clientX - rect.left) / rect.width;
    y = (t.clientY - rect.top) / rect.height;
  } else {
    x = (e.clientX - rect.left) / rect.width;
    y = (e.clientY - rect.top) / rect.height;
  }
  const now = performance.now();
  if (now - lastEmit > MOUSE_THROTTLE_MS) {
    for (let i = 0; i < multi; i++) {
      const jx = (Math.random() - 0.5) * 0.004;
      const jy = (Math.random() - 0.5) * 0.004;
      addDrop(x + jx, y + jy, now * 0.001);
    }
    lastEmit = now;
  }
}

window.addEventListener('mousemove', (e) => emitFromEvent(e, 1), { passive: true });
window.addEventListener('touchstart', (e) => emitFromEvent(e, 3), { passive: true });
window.addEventListener('touchmove', (e) => emitFromEvent(e, 1), { passive: true });

/* ===========================
   RENDER LOOP
   =========================== */
function render(timeMs) {
  resize();
  const t = timeMs * 0.001;

  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.uniform1i(u_tex, 0);

  gl.uniform2f(u_resolution, canvas.width, canvas.height);
  gl.uniform1f(u_time, t);

  for (let i = 0; i < MAX_DROPS; i++) {
    const d = drops[i];
    if (d.active && (t - d.t) > 6.0) d.active = 0;
    gl.uniform2f(u_centers[i], d.x, 1.0 - d.y);
    gl.uniform1f(u_startT[i], d.t);
    gl.uniform1f(u_active[i], d.active ? 1.0 : 0.0);
  }

  gl.drawArrays(gl.TRIANGLES, 0, 3);
  requestAnimationFrame(render);
}
requestAnimationFrame(render);

// Initial ripple
setTimeout(() => addDrop(0.5, 0.55, performance.now() * 0.001), 350);
</script>

</body>
</html>
